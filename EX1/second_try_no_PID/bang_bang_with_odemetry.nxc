#define LEFT      OUT_C
#define RIGHT     OUT_A
#define BOTH      OUT_AC

#define LIGHT     IN_3
#define TOUCH     IN_1

#define FILE_NAME "ROUTE.TXT"

// --- PHYSICAL CONSTANTS (YOU MUST MEASURE THESE) ---
// All units in cm
const float WHEEL_DIAMETER = 5.6;
const float TRACK_WIDTH = 11.8;   // Distance between center of left tire to center of right tire


// --- ODOMETRY VARIABLES ---
float x_cm = 0.0;
float y_cm = 0.0;
float theta_rad = 0.0;

long old_enc_left = 0;
long old_enc_right = 0;

// --- DATA LOGGING ---
// NXT has limited RAM. 2500 points * 3 floats is a safe limit.
#define MAX_LOG_POINTS 2500
float logX[MAX_LOG_POINTS];
float logY[MAX_LOG_POINTS];
float logTheta[MAX_LOG_POINTS];
int data_index = 0;
int loop_counter = 0;  // Counter for logging interval

// Base driving speed
int BASE_SPEED = 75; // Slower speed improves odometry accuracy

// Calibration values
int BLACK = 30;
int WHITE = 60;
int THRESHOLD;

// Logging interval - log every Nth iteration (increase to reduce rows)
#define LOG_INTERVAL 5  // Change this number to log more/less frequently

// Logging interval - log every Nth iteration (increase to reduce rows)
#define LOG_INTERVAL 5  // Change this number to log more/less frequently

byte fileHandle;

// --- FILE SAVING FUNCTION ---
void WriteLogToFile()
{
    DeleteFile(FILE_NAME);
    if (CreateFile(FILE_NAME, 10240, fileHandle) == LDR_SUCCESS) // Increased file size alloc
    {
        TextOut(0, LCD_LINE1, "SAVING DATA...");
        TextOut(0, LCD_LINE2, "PLEASE WAIT...");

        string str = "rows: ";
        str = StrCat(str, NumToStr(data_index));
        unsigned int bytesWritten1 = 0;
        WriteLnString(fileHandle, str, bytesWritten1);

        for(int i=0; i < data_index; i++) {
            // Convert floats to large integers to keep precision in the text file
            // X/Y * 10000, Theta * 100000
            long x_out = logX[i] * 10000;
            long y_out = logY[i] * 10000;
            long t_out = logTheta[i] * 100000;

            string s = NumToStr(x_out);
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(y_out));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(t_out));
            s = StrCat(s, "\n");

            unsigned int bytesWritten = 0;
            WriteString(fileHandle, s, bytesWritten);
        }
        CloseFile(fileHandle);
        PlaySound(SOUND_UP);
        TextOut(0, LCD_LINE3, "DONE!");
        Wait(2000);
    }
    else {
        TextOut(0, LCD_LINE1, "SAVE ERROR!");
        PlaySound(SOUND_LOW_BEEP);
        Wait(2000);
    }
}

task main()
{
    // 1. Setup Sensors
    SetSensorLight(LIGHT, true);
    SetSensor(TOUCH, SENSOR_TOUCH);

    // 2. Reset Encoders
    ResetTachoCount(LEFT);
    ResetTachoCount(RIGHT);
    old_enc_left = 0;
    old_enc_right = 0;

    // 3. Calculate threshold
    THRESHOLD = (BLACK + WHITE) / 2;

    TextOut(0, LCD_LINE1, "Ready to Run");
    Wait(1000);

    // --- MAIN LOOP ---
    while (Sensor(TOUCH) != 1)
    {
        // --- A. ODOMETRY CALCULATION ---

        // 1. Get current motor ticks
        long curr_enc_left = MotorRotationCount(LEFT);
        long curr_enc_right = MotorRotationCount(RIGHT);

        // 2. Calculate change in ticks since last loop
        long d_ticks_left = curr_enc_left - old_enc_left;
        long d_ticks_right = curr_enc_right - old_enc_right;

        // 3. Update "old" values for next loop
        old_enc_left = curr_enc_left;
        old_enc_right = curr_enc_right;

        // 4. Convert ticks to distance (cm)
        // distance = degrees * (Circumference / 360)
        float d_dist_left = d_ticks_left * (PI * WHEEL_DIAMETER / 360.0);
        float d_dist_right = d_ticks_right * (PI * WHEEL_DIAMETER / 360.0);

        // 5. Calculate Center Distance and Change in Orientation
        float d_center = (d_dist_left + d_dist_right) / 2.0;
        float d_theta = (d_dist_right - d_dist_left) / TRACK_WIDTH;

        // 6. Update Global Position (Integration)
        // Using average angle for better accuracy: theta + d_theta/2
        float avg_theta = theta_rad + (d_theta / 2.0);

        x_cm = x_cm + (d_center * cos(avg_theta));
        y_cm = y_cm + (d_center * sin(avg_theta));
        theta_rad = theta_rad + d_theta;

        // 7. Store Data (Log every LOG_INTERVAL iterations)
        loop_counter++;
        if (loop_counter >= LOG_INTERVAL) {
            if (data_index < MAX_LOG_POINTS) {
                logX[data_index] = x_cm;
                logY[data_index] = y_cm;
                logTheta[data_index] = theta_rad;
                data_index++;
            }
            loop_counter = 0;  // Reset counter
        }

        // --- B. LINE FOLLOWING LOGIC ---

        int lightValue = Sensor(LIGHT);

        if (lightValue < THRESHOLD)
        {
            // On the line - turn left
            OnFwd(LEFT, BASE_SPEED / 2.1);
            OnFwd(RIGHT, BASE_SPEED);
        }
        else
        {
            // Off the line - turn right
            OnFwd(LEFT, BASE_SPEED);
            OnFwd(RIGHT, BASE_SPEED / 2.1);
        }

        // Small delay is needed for stability, but too long makes odometry inaccurate
        Wait(20);
    }

    // Stop motors
    Off(BOTH);

    // Save the array to file
    WriteLogToFile();
}
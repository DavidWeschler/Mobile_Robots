#include "NXCDefs.h"

// --- PORTS ---
#define LEFT      OUT_C
#define RIGHT     OUT_A
#define BOTH      OUT_AC
#define LIGHT     IN_3
#define TOUCH     IN_1
#define FILE_NAME "ROUTE.TXT"

#ifndef SENSOR_TOUCH
#define SENSOR_TOUCH 0
#endif

// --- ROBOT CONSTANTS ---
const int BASE_SPEED = 60;
const int BLACK = 35;
const int WHITE = 60;
int THRESHOLD;

// MEASURE THESE CAREFULLY!
const float WHEEL_DIAMETER = 5.6;
const float WHEEL_CIRCUMFERENCE = 17.5929; // pi * 5.6
const float WHEEL_BASE = 12.0;             // Distance between center of wheels

const float RAD_TO_DEG = 57.29578;
const float DEG_TO_RAD = 0.017453;

// --- LOGGING (RAM) ---
// NXT Flash is slow. We save to RAM first, then file later.
#define MAX_POINTS 1500
float logX[MAX_POINTS];
float logY[MAX_POINTS];
float logTheta[MAX_POINTS];
int data_index = 0;

// --- ODOMETRY VARIABLES ---
float x = 0.0;
float y = 0.0;
float theta = 0.0; // Radians

float lastLeftTacho = 0;
float lastRightTacho = 0;

byte fileHandle;

// --- FUNCTION TO SAVE DATA ---
void WriteLogToFile()
{
    DeleteFile(FILE_NAME);
    if (CreateFile(FILE_NAME, 5120, fileHandle) == LDR_SUCCESS)
    {
        TextOut(0, LCD_LINE1, "SAVING DATA...");

        string str = "rows: ";
        str = StrCat(str, NumToStr(data_index));
        str = StrCat(str, "\n");
        unsigned int bytesWritten1 = 0;
        WriteString(fileHandle, str, bytesWritten1);


        for(int i=0; i < data_index; i++) {
            // Convert floats to integers for storage (avoids scientific notation issues in NXC)
            long x_out = logX[i] * 10000;
            long y_out = logY[i] * 10000;
            long t_out = logTheta[i] * 100000;

            string s = NumToStr(x_out);
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(y_out));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(t_out));
            s = StrCat(s, "\n");

            unsigned int bytesWritten = 0;
            WriteString(fileHandle, s, bytesWritten);
        }
        CloseFile(fileHandle);
        PlaySound(SOUND_UP);
    }
    else {
        TextOut(0, LCD_LINE1, "SAVE ERROR!");
        PlaySound(SOUND_LOW_BEEP);
    }
}

task main()
{
    // 1. Setup Sensors
    SetSensorLight(LIGHT, true);
    SetSensor(TOUCH, SENSOR_TOUCH);
    THRESHOLD = (BLACK + WHITE) / 2;

    // 2. Reset Hardware Counters (CRITICAL FOR PRECISION)
    ResetTachoCount(BOTH);
    Wait(100);
    lastLeftTacho = 0;
    lastRightTacho = 0;



    long last_log_time = CurrentTick();

    // 4. Main Loop
    while (Sensor(TOUCH) != 1)
    {
        // --- A. LINE FOLLOWING ---
        if (Sensor(LIGHT) < THRESHOLD) {
            OnFwd(LEFT, BASE_SPEED /1.5);
            OnFwd(RIGHT, BASE_SPEED);
        } else {
            OnFwd(LEFT, BASE_SPEED);
            OnFwd(RIGHT, BASE_SPEED / 1.5);
        }

        // --- B. EXACT ARC ODOMETRY ---

        // 1. Read Motors
        float currentLeft = MotorTachoCount(LEFT);
        float currentRight = MotorTachoCount(RIGHT);

        float deltaLeft = currentLeft - lastLeftTacho;
        float deltaRight = currentRight - lastRightTacho;

        lastLeftTacho = currentLeft;
        lastRightTacho = currentRight;

        // 2. Convert Degrees of Rotation to Distance (cm)
        float distLeft = (deltaLeft / 360.0) * WHEEL_CIRCUMFERENCE;
        float distRight = (deltaRight / 360.0) * WHEEL_CIRCUMFERENCE;

        // 3. Calculate Path Variables
        float deltaDist = (distLeft + distRight) / 2.0;
        float deltaTheta = (distRight - distLeft) / WHEEL_BASE; // Radians

        // 4. Calculate New Position (The "Two Step" / Exact Arc Method)
        if (abs(deltaTheta) < 0.0001) {
            // CASE 1: Moving Straight (approx)
            // If angle change is tiny, use 2nd Order Runge-Kutta (Midpoint)
            // This prevents "Divide by Zero" errors.
            float midTheta = theta + (deltaTheta / 2.0);
            float t_theta =  midTheta * RAD_TO_DEG;

            x += (deltaDist * Cos(t_theta));
            y += (deltaDist * Sin(t_theta));
            theta += deltaTheta;
        }
        else {
            // CASE 2: Moving in an Arc (Exact Solution)
            // Radius of Curvature R = deltaDist / deltaTheta
            float radius = deltaDist / deltaTheta;
            float oldTheta = theta;
            float newTheta = theta + deltaTheta;

            float t_theta_new =  newTheta * RAD_TO_DEG;
            float t_theta_old =  oldTheta * RAD_TO_DEG;

            // x_new = x_old + R * (sin(theta_new) - sin(theta_old))
            x += (radius * (Sin(t_theta_new) - Sin(t_theta_old)));

            // y_new = y_old - R * (cos(theta_new) - cos(theta_old))
            y -= (radius * (Cos(t_theta_new) - Cos(t_theta_old)));

            theta = newTheta;
        }

        // Normalize Theta to -PI to +PI
        while(theta > 3.14159) theta -= 6.28318;
        while(theta < -3.14159) theta += 6.28318;

        // --- C. LOGGING ---
        if (CurrentTick() - last_log_time > 100) {
            if (data_index < MAX_POINTS) {
                logX[data_index] = x;
                logY[data_index] = y;
                logTheta[data_index] = theta;
                data_index++;
            }
            last_log_time = CurrentTick();

            // Debug Display
            NumOut(0, LCD_LINE3, x);
            NumOut(50, LCD_LINE3, y);
        }

        // Fast loop frequency
        Wait(10);
    }

    // 5. Shutdown and Save
    Off(BOTH);
    WriteLogToFile();
    Wait(2000);
}
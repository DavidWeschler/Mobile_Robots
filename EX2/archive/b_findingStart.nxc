#define RIGHT_MOTOR     OUT_A
#define LEFT_MOTOR      OUT_B
#define BOTH_MOTORS    OUT_AB
#define ULTRASONIC_SENSOR S4
#define TOUCH_SENSOR    S1
#define LIGHT_SENSOR    S2

// --- PHYSICAL CONSTANTS (cm) ---
const float WHEEL_DIAMETER = 5.6;
const float TRACK_WIDTH    = 11.8;

const int TARGET_DISTANCE = 30;
const int DEAD_ZONE = 2;
const int BASE_SPEED = 50;
const int BLACK_THRESHOLD = 30;

// PID Constants
const float KP = 1.2;
const float KI = 0.005;
const float KD = 15.0;

const float INTEGRAL_MAX = 300;

// Global variables for the filter
const int N = 3;
int samples[N]; // Store last 3 readings
int lineCount = 0; // counts how many black lines we passed. when we get to 2, we stop the robot
bool onLine = false; // Flag to prevent counting the same line twice
bool wallHit = false; // Flag to track if we've hit the first wall

// Moving Average Filter
int GetFilteredDistance() {
    int raw = SensorUS(ULTRASONIC_SENSOR);
    if (raw > 255) raw = 255; // Cap weird spikes

    for (int i = N - 1; i > 0; i--) {
        samples[i] = samples[i - 1];
    }
    samples[0] = raw;

    // Return average
    int sum = 0;
    for (int i = 0; i < N; i++) {
        sum += samples[i];
    }

    return sum / N;
}

void CheckLine() {
    // If we have already finished, do nothing
    if (lineCount >= 2) return;

    if (Sensor(LIGHT_SENSOR) < BLACK_THRESHOLD) {
        if (onLine == false) {
            lineCount++;
            onLine = true;
            PlaySound(SOUND_CLICK); // Audio feedback when line is detected
        }
    } else {
        // Only reset if we see clearly white (hysteresis prevents flicker)
        if (Sensor(LIGHT_SENSOR) > BLACK_THRESHOLD + 5) {
            onLine = false;
        }
    }
}

task main()
{
    SetSensorLowspeed(ULTRASONIC_SENSOR);
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorLight(LIGHT_SENSOR, true);

    // Initialize filter array
    int initialDist = SensorUS(ULTRASONIC_SENSOR);
    for (int i = 0; i < N; i++) {
        if (initialDist > 255) initialDist = 255;
        samples[i] = initialDist;
    }

    ResetTachoCount(LEFT_MOTOR);
    ResetTachoCount(RIGHT_MOTOR);

    float integral = 0;
    int lastError = 0;

    TextOut(0, LCD_LINE1, "Finding Start");
    TextOut(0, LCD_LINE2, "Lines: 0");
    Wait(1000);

    while (true) {

        // CHECK FOR EXIT CONDITION - Stop at 2nd black line
        if (lineCount >= 2) {
            Off(OUT_AB);
            TextOut(0, LCD_LINE1, "FOUND START!");
            TextOut(0, LCD_LINE2, "Lines: 2");
            PlaySound(SOUND_UP);
            Wait(3000);
            break;
        }

        // CHECK LINE IN MAIN LOOP
        CheckLine();
        
        // Display line count
        string lineStr = "Lines: ";
        lineStr = StrCat(lineStr, NumToStr(lineCount));
        TextOut(0, LCD_LINE2, lineStr);

        // TOUCH SENSOR - Hit wall, turn right
        if (Sensor(TOUCH_SENSOR) == 1) {
            Off(LEFT_MOTOR); Off(RIGHT_MOTOR);
            Wait(200);

            // Back up exactly 180 degrees of wheel rotation
            RotateMotor(BOTH_MOTORS, BASE_SPEED, -180);

            Wait(200);
            // Turn Right: Rotate right motor backwards 360 degrees
            RotateMotor(RIGHT_MOTOR, BASE_SPEED, -360);

            // Mark that we've hit the wall - start wall-following mode
            wallHit = true;
            
            // Reset PID memory
            integral = 0;
            lastError = 0;
            
            // Re-prime the filter so we don't start with bad data
            int current = SensorUS(ULTRASONIC_SENSOR);
            for (int i = 0; i < N; i++) {
                samples[i] = current;
            }

            continue;
        }

        // CONTROL MODE: Before first wall hit, just go straight
        if (!wallHit) {
            OnFwd(LEFT_MOTOR, BASE_SPEED);
            OnFwd(RIGHT_MOTOR, BASE_SPEED);
        }
        // CONTROL MODE: After wall hit, use PID wall-following
        else {
            int distance = GetFilteredDistance();
            int error = distance - TARGET_DISTANCE;
            
            // Dead zone
            if (abs(error) < DEAD_ZONE) {
                error = 0;
            }

            // Integral with Anti-Windup
            if (abs(error) < 15) {
                integral += error;
            } else {
                integral = 0;
            }

            // Hard Clamp Integral
            if (integral > INTEGRAL_MAX) integral = INTEGRAL_MAX;
            if (integral < -INTEGRAL_MAX) integral = -INTEGRAL_MAX;

            int derivative = error - lastError;

            // PID Calculation
            float turnRatio = (KP * error) + (KI * integral) + (KD * derivative);

            // Calculate Speeds
            int leftSpeed  = BASE_SPEED - turnRatio;
            int rightSpeed = BASE_SPEED + turnRatio;

            // Absolute Safety Clamps
            if (leftSpeed < 0) leftSpeed = 0;
            if (rightSpeed < 0) rightSpeed = 0;
            if (leftSpeed > 100) leftSpeed = 100;
            if (rightSpeed > 100) rightSpeed = 100;

            OnFwd(LEFT_MOTOR, leftSpeed);
            OnFwd(RIGHT_MOTOR, rightSpeed);
            
            lastError = error;
        }

        // Loop timing
        Wait(40);
    }
}

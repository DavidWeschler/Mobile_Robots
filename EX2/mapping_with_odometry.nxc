#define RIGHT_MOTOR     OUT_A
#define LEFT_MOTOR      OUT_B
#define BOTH_MOTORS    OUT_AB
#define ULTRASONIC_SENSOR S4
#define TOUCH_SENSOR    S1
#define LIGHT_SENSOR    S2

#define FILE_NAME "MAP.TXT"

// --- PHYSICAL CONSTANTS (cm) ---
const float WHEEL_DIAMETER = 5.6;
const float TRACK_WIDTH    = 11.8;

// --- ODOMETRY VARIABLES ---
float x_cm = 0.0;
float y_cm = 0.0;
float theta_rad = 0.0;

long old_enc_left = 0;
long old_enc_right = 0;

// --- DATA LOGGING ---
#define MAX_LOG_POINTS 2000
float logX[MAX_LOG_POINTS];
float logY[MAX_LOG_POINTS];
float logTheta[MAX_LOG_POINTS];
int logDistance[MAX_LOG_POINTS];

int data_index = 0;
int loop_counter = 0;
#define LOG_INTERVAL 1     // Log every 5 PID cycles

byte fileHandle;


const int TARGET_DISTANCE = 30;
const int DEAD_ZONE = 2;
const int BASE_SPEED = 50;
const int BLACK_THRESHOLD = 30;

// PID Constants (You may need to re-tune these after removing ramping)
const float KP = 1.2;
const float KI = 0.005;         // Very small KI is safer
const float KD = 15.0;          // Increased KD to handle "braking" naturally

const float INTEGRAL_MAX = 300; // Lower cap for faster recovery

// Global variables for the filter
const int N = 3;
int samples[N]; // Store last 3 readings
int lineCount = 0; // counts how many black lines we passed. when we get to 4, we stop the robot
bool onLine = false; // Flag to prevent counting the same line twice

// 1. IMPROVEMENT: Weighted Moving Average Filter
// This smooths out sensor jitter before the PID sees it
int GetFilteredDistance() {
    int raw = SensorUS(ULTRASONIC_SENSOR);
    if (raw > 255) raw = 255; // Cap weird spikes

    for (int i = N - 1; i > 0; i--) {
        samples[i] = samples[i - 1];
    }
    samples[0] = raw;

    // Return average (Integer math is fine here)
    int sum = 0;
    for (int i = 0; i < N; i++) {
        sum += samples[i];
    }

    return sum / N;
}

void CheckLine() {
    // If we have already finished, do nothing
    if (lineCount >= 4) return;

    if (Sensor(LIGHT_SENSOR) < BLACK_THRESHOLD) {
        if (onLine == false) {
            lineCount++;
            onLine = true;
        }
    } else {
        // Only reset if we see clearly white (hysteresis prevents flicker)
        if (Sensor(LIGHT_SENSOR) > BLACK_THRESHOLD + 5) {
            onLine = false;
        }
    }
}

void WriteLogToFile()
{
    DeleteFile(FILE_NAME);
    if (CreateFile(FILE_NAME, 15000, fileHandle) == LDR_SUCCESS)
    {
        TextOut(0, LCD_LINE1, "SAVING...");
        TextOut(0, LCD_LINE2, "PLEASE WAIT");


        for (int i = 0; i < data_index; i++)
        {
            long xo = logX[i] * 10000;
            long yo = logY[i] * 10000;
            long to = logTheta[i] * 100000;

            string s = NumToStr(xo);
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(yo));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(to));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(logDistance[i]));
            s = StrCat(s, "\n");

            unsigned int bw = 0;
            WriteString(fileHandle, s, bw);
        }

        CloseFile(fileHandle);
        PlaySound(SOUND_UP);
        TextOut(0, LCD_LINE3, "DONE!");
        Wait(2000);
    }
    else {
        TextOut(0, LCD_LINE1, "SAVE ERROR");
        PlaySound(SOUND_LOW_BEEP);
        Wait(2000);
    }
}

task main()
{
    SetSensorLowspeed(ULTRASONIC_SENSOR);
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorLight(LIGHT_SENSOR, true);

    // Initialize filter array
    int initialDist = SensorUS(ULTRASONIC_SENSOR);
    for (int i = 0; i < N; i++) {
        if (initialDist > 255) initialDist = 255;
        samples[i] = initialDist;
    }


    ResetTachoCount(LEFT_MOTOR);
    ResetTachoCount(RIGHT_MOTOR);
    old_enc_left = 0;
    old_enc_right = 0;

    float integral = 0;
    int lastError = 0;

    while (true) {

        // ===== ODOMETRY =====

        long curr_enc_left  = MotorRotationCount(LEFT_MOTOR);
        long curr_enc_right = MotorRotationCount(RIGHT_MOTOR);

        long d_ticks_left  = curr_enc_left  - old_enc_left;
        long d_ticks_right = curr_enc_right - old_enc_right;

        old_enc_left  = curr_enc_left;
        old_enc_right = curr_enc_right;

        float d_left  = d_ticks_left  * (PI * WHEEL_DIAMETER / 360.0);
        float d_right = d_ticks_right * (PI * WHEEL_DIAMETER / 360.0);

        float d_center = (d_left + d_right) / 2.0;
        float d_theta  = (d_right - d_left) / TRACK_WIDTH;

        float avg_theta = theta_rad + (d_theta / 2.0);

        x_cm += d_center * cos(avg_theta);
        y_cm += d_center * sin(avg_theta);
        theta_rad += d_theta;
        int distance = GetFilteredDistance();
        // Log every Nth iteration
        loop_counter++;
        if (loop_counter >= LOG_INTERVAL && lineCount>=2)
        {
            if (data_index < MAX_LOG_POINTS)
            {
                logX[data_index]     = x_cm;
                logY[data_index]     = y_cm;
                logTheta[data_index] = theta_rad;
                logDistance[data_index] = distance;
                data_index++;
            }
            loop_counter = 0;
        }

        // 0. CHECK FOR EXIT CONDITION
        if (lineCount >= 4) {
            Off(OUT_AB);
            Wait(500); // Standard wait is fine here as we are done
            break;
        }

        // 1. CHECK LINE IN MAIN LOOP
        CheckLine();

        // --- 2. IMPROVEMENT: Encoder-Based Corner Recovery ---
        if (Sensor(TOUCH_SENSOR) == 1) {
            Off(LEFT_MOTOR); Off(RIGHT_MOTOR);
            Wait(200);

            // Back up exactly 180 degrees of wheel rotation
            RotateMotor(BOTH_MOTORS, BASE_SPEED, -180);

            Wait(200);
            CheckLine();

            // Turn Right: Move Left Motor Fwd, Right Motor Rev
            RotateMotor(RIGHT_MOTOR, BASE_SPEED, -360);
            CheckLine();

            // Reset PID memory
            integral = 0;
            lastError = 0;
            // Re-prime the filter so we don't start with bad data
            int current = SensorUS(ULTRASONIC_SENSOR);
            for (int i = 0; i < N; i++) {
                samples[i] = current;
            }

            continue;
        }

        // --- PID CONTROL ---

        distance = GetFilteredDistance();
        int error = distance - TARGET_DISTANCE;

        // Dead zone
        if (abs(error) < DEAD_ZONE) {
            error = 0;
        }

        // Integral with Anti-Windup
        // Only accumulate integral if error is small (fine tuning range)
        if (abs(error) < 15) {
            integral += error;
        } else {
            integral = 0; // Zero out integral if we are way off course
        }

        // Hard Clamp Integral
        if (integral > INTEGRAL_MAX) integral = INTEGRAL_MAX;
        if (integral < -INTEGRAL_MAX) integral = -INTEGRAL_MAX;

        int derivative = error - lastError;

        // PID Calculation
        float turnRatio = (KP * error) + (KI * integral) + (KD * derivative);

        // Calculate Speeds
        int leftSpeed  = BASE_SPEED - turnRatio;
        int rightSpeed = BASE_SPEED + turnRatio;

        // --- 3. IMPROVEMENT: Removed Ramping "MAX_DELTA" ---
        // Let the PID do the work. If it's too jerky, decrease KP or increase KD.

        // Absolute Safety Clamps
        if (leftSpeed < 0) leftSpeed = 0;
        if (rightSpeed < 0) rightSpeed = 0;
        if (leftSpeed > 100) leftSpeed = 100;
        if (rightSpeed > 100) rightSpeed = 100;

        OnFwd(LEFT_MOTOR, leftSpeed);
        OnFwd(RIGHT_MOTOR, rightSpeed);

        lastError = error;

        // --- 4. IMPROVEMENT: Slower Loop Time ---
        // 40ms is better for US sensor stability
        Wait(40);
    }
    WriteLogToFile();
}
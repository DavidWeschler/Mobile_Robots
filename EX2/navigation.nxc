#define RIGHT_MOTOR     OUT_A
#define LEFT_MOTOR      OUT_B
#define BOTH_MOTORS     OUT_AB
#define ULTRASONIC_SENSOR S4
#define TOUCH_SENSOR    S1
#define LIGHT_SENSOR    S2
#define SOUND_SENSOR    S3

// --- PHYSICAL CONSTANTS (cm) ---
const float WHEEL_DIAMETER = 5.6;
const float TRACK_WIDTH    = 12.1;
const int TARGET_DISTANCE = 30;
const int DEAD_ZONE = 2;
const int BASE_SPEED = 50;
const int BLACK_THRESHOLD = 30;
const int CLAP_THRESHOLD = 60;

// --- PID CONSTANTS ---
const float KP = 1.2;
const float KI = 0.005;
const float KD = 15.0;
const float INTEGRAL_MAX = 300;

// --- GLOBAL VARIABLES ---
// Filter globals
const int N = 3;
const int WAIT_TIME_MS = 3000;
int samples[N];

// Navigation state globals
int lineCount = 0;
bool onLine = false;
bool wallHit = false;

// PID state globals
float integral = 0;
int lastError = 0;

// ---------------------------------------------------------
// 1. SENSOR & FILTER FUNCTIONS
// ---------------------------------------------------------

void SetupRobot() {
    SetSensorLowspeed(ULTRASONIC_SENSOR);
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorLight(LIGHT_SENSOR, true);
    SetSensorSound(SOUND_SENSOR);

    ResetTachoCount(LEFT_MOTOR);
    ResetTachoCount(RIGHT_MOTOR);

    // Initialize filter array with current reading
    int initialDist = SensorUS(ULTRASONIC_SENSOR);
    if (initialDist > 255) initialDist = 255;
    
    for (int i = 0; i < N; i++) {
        samples[i] = initialDist;
    }
}

int GetFilteredDistance() {
    int raw = SensorUS(ULTRASONIC_SENSOR);
    if (raw > 255) raw = 255; 

    // Shift array
    for (int i = N - 1; i > 0; i--) {
        samples[i] = samples[i - 1];
    }
    samples[0] = raw;

    // Calculate Average
    int sum = 0;
    for (int i = 0; i < N; i++) {
        sum += samples[i];
    }
    return sum / N;
}

void CheckLine() {
    // If we have already found the start, stop checking
    if (lineCount >= 2) return;

    if (Sensor(LIGHT_SENSOR) < BLACK_THRESHOLD) {
        if (!onLine) {
            lineCount++;
            onLine = true;
            PlaySound(SOUND_CLICK); 
        }
    } else {
        // Hysteresis: Only reset if clearly white
        if (Sensor(LIGHT_SENSOR) > BLACK_THRESHOLD + 5) {
            onLine = false;
        }
    }
    
    // Display Update
    string lineStr = "Lines: ";
    lineStr = StrCat(lineStr, NumToStr(lineCount));
    TextOut(0, LCD_LINE2, lineStr);
}

// ---------------------------------------------------------
// 2. MOVEMENT & COLLISION FUNCTIONS
// ---------------------------------------------------------

void HandleWallCollision() {
    Off(BOTH_MOTORS);
    Wait(200);

    // Back up and Turn
    RotateMotor(BOTH_MOTORS, BASE_SPEED, -180);
    Wait(200);
    RotateMotor(RIGHT_MOTOR, BASE_SPEED, -360);

    // Update State
    wallHit = true;
    
    // Reset PID Memory
    integral = 0;
    lastError = 0;
    
    // Re-prime the filter to avoid derivative spikes
    int current = SensorUS(ULTRASONIC_SENSOR);
    if (current > 255) current = 255;
    for (int i = 0; i < N; i++) {
        samples[i] = current;
    }
}

void DrivePID() {
    int distance = GetFilteredDistance();
    int error = distance - TARGET_DISTANCE;
    
    // Dead zone
    if (abs(error) < DEAD_ZONE) error = 0;

    // Integral calculation with Anti-Windup
    if (abs(error) < 15) {
        integral += error;
    } else {
        integral = 0;
    }

    // Clamp Integral
    if (integral > INTEGRAL_MAX) integral = INTEGRAL_MAX;
    if (integral < -INTEGRAL_MAX) integral = -INTEGRAL_MAX;

    int derivative = error - lastError;

    // Calculate Turn Ratio
    float turnRatio = (KP * error) + (KI * integral) + (KD * derivative);

    // Apply Motors
    int leftSpeed  = BASE_SPEED - turnRatio;
    int rightSpeed = BASE_SPEED + turnRatio;

    // Safety Clamps
    if (leftSpeed < 0) leftSpeed = 0;
    if (rightSpeed < 0) rightSpeed = 0;
    if (leftSpeed > 100) leftSpeed = 100;
    if (rightSpeed > 100) rightSpeed = 100;

    OnFwd(LEFT_MOTOR, leftSpeed);
    OnFwd(RIGHT_MOTOR, rightSpeed);
    
    lastError = error;
}

// ---------------------------------------------------------
// 3. PHASE LOGIC
// ---------------------------------------------------------

void ExecutePhase1() {
    TextOut(0, LCD_LINE1, "Finding Start");
    
    while (lineCount < 2) {
        CheckLine();

        // High priority: Collision check
        if (Sensor(TOUCH_SENSOR) == 1) {
            HandleWallCollision();
            continue; // Skip the rest of the loop to restart movement logic
        }

        // Movement Logic
        if (!wallHit) {
            // No wall hit yet? Just drive straight
            OnFwd(LEFT_MOTOR, BASE_SPEED);
            OnFwd(RIGHT_MOTOR, BASE_SPEED);
        } else {
            // Wall hit? Use PID
            DrivePID();
        }

        Wait(40); // Loop timing
    }
    Off(BOTH_MOTORS);
    lineCount = 0; // Reset for next phase
    wallHit = false; // Reset wall hit state
}

void waitForStartSignal() {
    Off(BOTH_MOTORS); 
    
    // STEP 1: Signal found
    PlaySound(SOUND_DOUBLE_BEEP);
    ClearScreen();
    TextOut(0, LCD_LINE1, "START FOUND!");
    TextOut(0, LCD_LINE2, "Waiting 15s...");
    
    // STEP 2: Mandatory Wait
    Wait(WAIT_TIME_MS);
    
    // STEP 3: Wait for Time or Clap
    ClearScreen();
    TextOut(0, LCD_LINE1, "WAITING SIGNAL:");
    TextOut(0, LCD_LINE2, "Clap OR 15s");
    
    long startTime = CurrentTick();
    
    while (CurrentTick() - startTime < WAIT_TIME_MS) {
        if (Sensor(SOUND_SENSOR) > CLAP_THRESHOLD) {
            TextOut(0, LCD_LINE4, "CLAP DETECTED!");
            break; 
        }
        Wait(10);
    }
    
    // STEP 4: Proceed
    ClearScreen();
    TextOut(0, LCD_LINE1, "PHASE 2 START");
    PlaySound(SOUND_UP);
    Wait(1000);
}

// ---------------------------------------------------------
// 4. PHASE 2: CENTER NAVIGATION
// ---------------------------------------------------------

// for regular shapes
void ExecutePhase2() {
    ClearScreen();
    TextOut(0, LCD_LINE1, "PHASE 2: CENTER");
    
    byte handle;
    unsigned int fsize;
    string sLine="";
    int numCorners = 0;
    float sumX = 0;
    float sumY = 0;
    
    // 1. Read File
    if (OpenFileRead("CENTER.TXT", fsize, handle) != 0) { // LDR_SUCCESS = 0
        PlaySound(SOUND_LOW_BEEP);
        TextOut(0, LCD_LINE2, "FILE NOT FOUND");
        Wait(5000);
        return;
    }
    
    // Read number of corners
    if (ReadLnString(handle, sLine) != 0) {
         CloseFile(handle);
         return;
    }
    numCorners = StrToNum(sLine);
    
    if (numCorners <= 0) {
        TextOut(0, LCD_LINE2, "NO CORNERS");
        CloseFile(handle);
        Wait(5000);
        return;
    }

    for (int i=0; i<numCorners; i++) {
        string sX, sY;
        ReadLnString(handle, sX);
        ReadLnString(handle, sY);
        sumX += StrToNum(sX);
        sumY += StrToNum(sY);
    }
    CloseFile(handle);
    
    float centerX = sumX / numCorners;
    float centerY = sumY / numCorners;
    
    float dist = sqrt(centerX*centerX + centerY*centerY);
    float angle = atan2(centerY, centerX); // Radians
    angle = (angle * 180.0) / 3.14159; // Degrees
    
    string sDist = NumToStr(dist);
    string sAngle = NumToStr(angle);
    
    TextOut(0, LCD_LINE2, "Dist: ");
    TextOut(40, LCD_LINE2, sDist);
    TextOut(0, LCD_LINE3, "Ang: ");
    TextOut(40, LCD_LINE3, sAngle);
    
    Wait(2000);
    // dist = 103.0;
    // angle = -43.0;
    
    // 2. Calculate Motor Rotations
    // Turn Angle
    // Wheel rotation needed for turn = (Angle * TrackWidth) / WheelDiameter
    float turnRotations = (angle * TRACK_WIDTH) / WHEEL_DIAMETER;
    
    // Drive Distance
    // Wheel rotation needed for dist = (Dist / (PI * WheelDiameter)) * 360
    float driveRotations = (dist / (3.14159 * WHEEL_DIAMETER)) * 360.0;
    
    // 3. Execute Turn
    // RotateMotorEx(ports, speed, degrees, turnPct, sync, stop)
    // turnPct = 100 means motors turn in opposite directions.
    RotateMotorEx(BOTH_MOTORS, BASE_SPEED, turnRotations, 100, true, true);
    Wait(500);
    
    // 4. Execute Drive
    // turnPct = 0 means straight
    RotateMotorEx(BOTH_MOTORS, BASE_SPEED, driveRotations, 0, true, true);
    
    // 5. Stop
    Off(BOTH_MOTORS);
    PlaySound(SOUND_DOWN);
    TextOut(0, LCD_LINE4, "ARRIVED");
}

// for irregular shapes
void ExecutePhase2_ver2() {
    ClearScreen();
    TextOut(0, LCD_LINE1, "PHASE 2: CENTER");
    
    byte handle;
    unsigned int fsize;
    string sLine="";
    int numCorners = 0;

    // arrays to store all corners
    float X[50];
    float Y[50];
    
    // 1. Read File
    if (OpenFileRead("CENTER.TXT", fsize, handle) != 0) {
        PlaySound(SOUND_LOW_BEEP);
        TextOut(0, LCD_LINE2, "FILE NOT FOUND");
        Wait(5000);
        return;
    }
    
    // Read number of corners
    if (ReadLnString(handle, sLine) != 0) {
        CloseFile(handle);
        return;
    }
    numCorners = StrToNum(sLine);
    
    if (numCorners <= 0) {
        TextOut(0, LCD_LINE2, "NO CORNERS");
        CloseFile(handle);
        Wait(5000);
        return;
    }

    // Read all corners into arrays
    for (int i=0; i<numCorners; i++) {
        string sX, sY;
        ReadLnString(handle, sX);
        ReadLnString(handle, sY);
        X[i] = StrToNum(sX);
        Y[i] = StrToNum(sY);
    }
    CloseFile(handle);
    
    // ---------- Compute centroid using shoelace formula ----------
    float A = 0.0;
    float Cx = 0.0;
    float Cy = 0.0;

    for (int i=0; i<numCorners; i++) {
        int j = (i + 1) % numCorners; // next vertex (wrap-around)
        
        float cross = X[i] * Y[j] - X[j] * Y[i];
        A  += cross;
        Cx += (X[i] + X[j]) * cross;
        Cy += (Y[i] + Y[j]) * cross;
    }

    A = A / 2.0;
    Cx = Cx / (6.0 * A);
    Cy = Cy / (6.0 * A);
    // -------------------------------------------------------------

    float centerX = Cx;
    float centerY = Cy;

    float dist = sqrt(centerX*centerX + centerY*centerY);
    float angle = atan2(centerY, centerX); // Radians
    angle = (angle * 180.0) / 3.14159; // Degrees
    
    string sDist = NumToStr(dist);
    string sAngle = NumToStr(angle);
    
    TextOut(0, LCD_LINE2, "Dist: ");
    TextOut(40, LCD_LINE2, sDist);
    TextOut(0, LCD_LINE3, "Ang: ");
    TextOut(40, LCD_LINE3, sAngle);
    
    Wait(2000);
    
    // 2. Calculate Motor Rotations
    float turnRotations = (angle * TRACK_WIDTH) / WHEEL_DIAMETER;
    float driveRotations = (dist / (3.14159 * WHEEL_DIAMETER)) * 360.0;
    
    // 3. Execute Turn
    RotateMotorEx(BOTH_MOTORS, BASE_SPEED, turnRotations, 100, true, true);
    Wait(500);
    
    // 4. Execute Drive
    RotateMotorEx(BOTH_MOTORS, BASE_SPEED, driveRotations, 0, true, true);
    
    // 5. Stop
    Off(BOTH_MOTORS);
    PlaySound(SOUND_DOWN);
    TextOut(0, LCD_LINE4, "ARRIVED");
}


// ---------------------------------------------------------
// 5. MAIN TASK
// ---------------------------------------------------------

task main()
{
    // 1. Initialize Hardware and Vars
    SetupRobot();
    Wait(300);

    // 2. Run Phase 1 (Find Start Point)
    // ExecutePhase1();


    // 3. Wait for start signal (Clap/Time)
    // waitForStartSignal();

    // 4. Run Phase 2 (Drive to center)
    ExecutePhase2(); 

    waitForStartSignal();
    ExecutePhase1();
}
// ==================================================================
// SANITY CHECK: WALL FOLLOWER + LINE COUNTER (Target: 8 Lines)
// ==================================================================

#define RIGHT_MOTOR     OUT_A
#define LEFT_MOTOR      OUT_B
#define BOTH_MOTORS     OUT_AB

#define ULTRASONIC_SENSOR S4
#define TOUCH_SENSOR    S1
#define LIGHT_SENSOR    S2

// --- TUNING CONSTANTS ---
const int TARGET_DISTANCE = 30;   // Distance from wall (cm)
const int BASE_SPEED = 50;        // Standard forward speed
const int BLACK_THRESHOLD = 30;   // Light sensor reading for black line
const int TARGET_LINE_COUNT = 8;  // Stop after this many lines

// PID Constants (Kept from your reference code)
const float KP = 1.2;
const float KI = 0.005;
const float KD = 15.0;
const int DEAD_ZONE = 2;
const float INTEGRAL_MAX = 300;

// --- GLOBAL VARIABLES ---
int lineCount = 0;
bool onLine = false;

// Filter Variables
const int N = 3;
int samples[N];

// ------------------------------------------------------------------
// FUNCTION: Weighted Moving Average Filter (Reduces Sensor Noise)
// ------------------------------------------------------------------
int GetFilteredDistance() {
    int raw = SensorUS(ULTRASONIC_SENSOR);
    if (raw > 255) raw = 255;

    // Shift old samples
    for (int i = N - 1; i > 0; i--) {
        samples[i] = samples[i - 1];
    }
    samples[0] = raw;

    // Calculate Average
    int sum = 0;
    for (int i = 0; i < N; i++) {
        sum += samples[i];
    }
    return sum / N;
}

// ------------------------------------------------------------------
// FUNCTION: Check for Black Lines
// ------------------------------------------------------------------
void CheckLine() {
    int lightValue = Sensor(LIGHT_SENSOR);

    // If we see a black line (value drops below threshold)
    if (lightValue < BLACK_THRESHOLD) {
        if (onLine == false) {
            lineCount++;     // Increment count
            onLine = true;   // Set flag so we don't count the same line twice

            // Optional: Beep to confirm detection
            PlaySound(SOUND_CLICK);
            TextOut(0, LCD_LINE4, "Lines detected:");
            NumOut(0, LCD_LINE5, lineCount);
        }
    }
    // Hysteresis: Only reset flag if we see clearly white again
    else if (lightValue > (BLACK_THRESHOLD + 5)) {
        onLine = false;
    }
}

// ------------------------------------------------------------------
// MAIN TASK
// ------------------------------------------------------------------
task main()
{
    // 1. Setup Sensors
    SetSensorLowspeed(ULTRASONIC_SENSOR);
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorLight(LIGHT_SENSOR, true); // 'true' turns on the red LED

    // 2. Initialize Filter Array
    int initialDist = SensorUS(ULTRASONIC_SENSOR);
    for (int i = 0; i < N; i++) {
        if (initialDist > 255) initialDist = 255;
        samples[i] = initialDist;
    }

    // 3. Reset Variables
    lineCount = 0;
    onLine = false;
    float integral = 0;
    int lastError = 0;

    TextOut(0, LCD_LINE1, "SANITY CHECK");
    TextOut(0, LCD_LINE2, "Target: 8 Lines");

    // ----------------- MAIN LOOP -----------------
    while (true) {

        // A. CHECK EXIT CONDITION
        if (lineCount >= TARGET_LINE_COUNT) {
            Off(BOTH_MOTORS);
            PlaySound(SOUND_UP);
            TextOut(0, LCD_LINE8, "DONE: 8 LINES!");
            Wait(5000); // Wait 5 seconds so you can see the screen
            break;      // Exit program
        }

        // B. CHECK SENSORS
        CheckLine();
        int distance = GetFilteredDistance();

        // C. COLLISION RECOVERY (Touch Sensor)
        if (Sensor(TOUCH_SENSOR) == 1) {
            Off(BOTH_MOTORS);
            PlaySound(SOUND_LOW_BEEP);
            Wait(200);

            // Back up
            RotateMotor(BOTH_MOTORS, BASE_SPEED, -180);
            Wait(200);

            // Turn Right (Spin on spot to find wall again)
            RotateMotor(RIGHT_MOTOR, BASE_SPEED, -360);
            

            // Reset PID memory so we don't jump immediately
            integral = 0;
            lastError = 0;

            // Refill filter to prevent bad reading spikes
            int current = SensorUS(ULTRASONIC_SENSOR);
            for (int i = 0; i < N; i++) samples[i] = current;

            continue; // Skip the rest of the loop
        }

        // D. PID CALCULATION
        int error = distance - TARGET_DISTANCE;

        // Dead zone to prevent jitter
        if (abs(error) < DEAD_ZONE) error = 0;

        // Integral Anti-Windup
        if (abs(error) < 10) {
            integral += error;
        } else {
            integral = 0;
        }

        // Clamp Integral
        if (integral > INTEGRAL_MAX) integral = INTEGRAL_MAX;
        if (integral < -INTEGRAL_MAX) integral = -INTEGRAL_MAX;

        int derivative = error - lastError;

        // Calculate Turn
        float turnRatio = (KP * error) + (KI * integral) + (KD * derivative);

        // Calculate Motor Speeds
        int leftSpeed  = BASE_SPEED - turnRatio;
        int rightSpeed = BASE_SPEED + turnRatio;

        // Clamp Speeds (0 - 100)
        if (leftSpeed < 0) leftSpeed = 0;
        if (rightSpeed < 0) rightSpeed = 0;
        if (leftSpeed > 100) leftSpeed = 100;
        if (rightSpeed > 100) rightSpeed = 100;

        // E. APPLY POWER
        OnFwd(LEFT_MOTOR, leftSpeed);
        OnFwd(RIGHT_MOTOR, rightSpeed);

        lastError = error;

        // Short wait for control loop stability
        Wait(40);
    }
}

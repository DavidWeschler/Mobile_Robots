// ==================================================================
// WALL FOLLOWER + AUTO-SCALING MAP
// ==================================================================

#define RIGHT_MOTOR     OUT_A
#define LEFT_MOTOR      OUT_B
#define BOTH_MOTORS     OUT_AB

#define ULTRASONIC_SENSOR S4
#define TOUCH_SENSOR    S1
#define SOUND_SENSOR    S2

// --- PHYSICAL CONSTANTS ---
const float WHEEL_DIAMETER = 5.6;
const float TRACK_WIDTH    = 11.8;

// --- MAPPING CONFIGURATION ---
#define MAX_POINTS 1500         // Maximum points to store in memory
#define DRAW_INTERVAL 1000      // Redraw every 1000ms (1 second)
#define MIN_SAVE_DIST 2.0       // Only save point if moved 2cm (Reduces lag)

// --- MEMORY ARRAYS (UPDATED FOR 4 COLUMNS) ---
float pathX[MAX_POINTS];
float pathY[MAX_POINTS];
float pathTheta[MAX_POINTS];    // New Column: Angle
int   pathDist[MAX_POINTS];     // New Column: Distance sensor
int pointCount = 0;
long lastDrawTime = 0;

// --- ODOMETRY VARIABLES ---
float x_cm = 0.0;
float y_cm = 0.0;
float theta_rad = 1.57; // Start facing UP (90 deg)

long old_enc_left = 0;
long old_enc_right = 0;

// --- TUNING ---
const int TARGET_DISTANCE = 30;
const int BASE_SPEED = 50;
const int BLACK_THRESHOLD = 30;
const int TARGET_LINE_COUNT = 8;

// --- PID VARIABLES ---
const float KP = 1.2;
const float KI = 0.005;
const float KD = 15.0;
const int DEAD_ZONE = 2;
const float INTEGRAL_MAX = 300;

// --- GLOBAL VARIABLES ---
int lineCount = 0;
const int N = 3;
int samples[N];
byte fileHandle;

// ------------------------------------------------------------------
// FUNCTION: Filter Sensor Noise
// ------------------------------------------------------------------
int GetFilteredDistance() {
    int raw = SensorUS(ULTRASONIC_SENSOR);
    if (raw > 255) raw = 255;
    for (int i = N - 1; i > 0; i--) samples[i] = samples[i - 1];
    samples[0] = raw;
    int sum = 0;
    for (int i = 0; i < N; i++) sum += samples[i];
    return sum / N;
}

// ------------------------------------------------------------------
// FUNCTION: Redraw Map (Auto-Scaling)
// ------------------------------------------------------------------
void RedrawMap() {
    if (pointCount < 2) return;

    // 1. Find Min/Max to auto-fit the screen
    float min_x = pathX[0]; float max_x = pathX[0];
    float min_y = pathY[0]; float max_y = pathY[0];

    for(int i=1; i < pointCount; i++) {
        if (pathX[i] < min_x) min_x = pathX[i];
        if (pathX[i] > max_x) max_x = pathX[i];
        if (pathY[i] < min_y) min_y = pathY[i];
        if (pathY[i] > max_y) max_y = pathY[i];
    }

    // 2. Calculate Range
    float range_x = max_x - min_x;
    float range_y = max_y - min_y;

    // Prevent divide by zero if robot hasn't moved
    if (range_x < 1.0) range_x = 1.0;
    if (range_y < 1.0) range_y = 1.0;

    // 3. Calculate Scale Factors (Screen is 100x64)
    // We leave a 2-pixel margin
    float scale_x = 96.0 / range_x;
    float scale_y = 60.0 / range_y;

    // Pick the smaller scale to maintain aspect ratio (don't stretch the map)
    float scale = scale_x;
    if (scale_y < scale_x) scale = scale_y;

    // 4. Draw
    ClearScreen();
    
    // Draw Start Point (Circle)
    int sx = (pathX[0] - min_x) * scale + 2;
    int sy = (pathY[0] - min_y) * scale + 2;
    CircleOut(sx, sy, 2);

    // Draw all segments
    for(int i=0; i < pointCount-1; i++) {
        int x1 = (pathX[i]   - min_x) * scale + 2;
        int y1 = (pathY[i]   - min_y) * scale + 2;
        int x2 = (pathX[i+1] - min_x) * scale + 2;
        int y2 = (pathY[i+1] - min_y) * scale + 2;
        
        LineOut(x1, y1, x2, y2);
    }
    
    // Draw Current Position (X)
    int ex = (pathX[pointCount-1] - min_x) * scale + 2;
    int ey = (pathY[pointCount-1] - min_y) * scale + 2;
    LineOut(ex-2, ey-2, ex+2, ey+2);
    LineOut(ex-2, ey+2, ex+2, ey-2);
}

// ------------------------------------------------------------------
// FUNCTION: Calculate Position & Update Array
// ADDED ARGUMENT: current_dist (to save to array)
// ------------------------------------------------------------------
void UpdateOdometry(int current_dist) {
    long curr_enc_left  = MotorRotationCount(LEFT_MOTOR);
    long curr_enc_right = MotorRotationCount(RIGHT_MOTOR);

    long d_ticks_left  = curr_enc_left  - old_enc_left;
    long d_ticks_right = curr_enc_right - old_enc_right;

    old_enc_left  = curr_enc_left;
    old_enc_right = curr_enc_right;

    float dist_per_tick = (PI * WHEEL_DIAMETER) / 360.0;
    float d_left  = d_ticks_left  * dist_per_tick;
    float d_right = d_ticks_right * dist_per_tick;

    float d_center = (d_left + d_right) / 2.0;
    float d_theta  = (d_right - d_left) / TRACK_WIDTH;

    float avg_theta = theta_rad + (d_theta / 2.0);

    x_cm += d_center * cos(avg_theta);
    y_cm += d_center * sin(avg_theta);
    theta_rad += d_theta;

    // --- SAVE POINT LOGIC ---
    if (pointCount < MAX_POINTS) {
        
        // If it's the first point, always save
        if (pointCount == 0) {
            pathX[0] = x_cm;
            pathY[0] = y_cm;
            pathTheta[0] = theta_rad;    // Save Theta
            pathDist[0] = current_dist;  // Save Distance
            pointCount++;
        } 
        else {
            // Check distance from last saved point
            float dx = x_cm - pathX[pointCount-1];
            float dy = y_cm - pathY[pointCount-1];
            float dist = sqrt(dx*dx + dy*dy);
            
            if (dist >= MIN_SAVE_DIST) {
                pathX[pointCount] = x_cm;
                pathY[pointCount] = y_cm;
                pathTheta[pointCount] = theta_rad;   // Save Theta
                pathDist[pointCount] = current_dist; // Save Distance
                pointCount++;
            }
        }
    }
}

// ------------------------------------------------------------------
// MAIN TASK
// ------------------------------------------------------------------
task main()
{
    // Setup
    SetSensorLowspeed(ULTRASONIC_SENSOR);
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorSound(SOUND_SENSOR);

    ResetTachoCount(LEFT_MOTOR);
    ResetTachoCount(RIGHT_MOTOR);

    // Init Filter
    int initialDist = SensorUS(ULTRASONIC_SENSOR);
    for (int i = 0; i < N; i++) samples[i] = initialDist;

    // Variables
    float integral = 0;
    int lastError = 0;
    lastDrawTime = CurrentTick();

    // ----------------- MAIN LOOP -----------------
    while (Sensor(SOUND_SENSOR) < 99) {

        // Get Distance FIRST so we can log it in Odometry
        int distance = GetFilteredDistance();

        // A. ODOMETRY (Pass distance to log it)
        UpdateOdometry(distance);
        
        // B. MAP REFRESH TIMER (Every 1 Second)
        if (CurrentTick() - lastDrawTime > DRAW_INTERVAL) {
            RedrawMap();
            lastDrawTime = CurrentTick();
        }

        // D. COLLISION RECOVERY
        if (Sensor(TOUCH_SENSOR) == 1) {
            Off(BOTH_MOTORS);
            PlaySound(SOUND_LOW_BEEP);
            Wait(200);

            RotateMotor(BOTH_MOTORS, BASE_SPEED, -240);
            RotateMotor(RIGHT_MOTOR, BASE_SPEED, -360);

            // Update odometry with new distance after recovery
            // (Re-read sensor for accuracy)
            int recoveryDist = GetFilteredDistance();
            UpdateOdometry(recoveryDist);

            integral = 0;
            lastError = 0;
            
            // Refill filter
            int current = SensorUS(ULTRASONIC_SENSOR);
            for (int i=0; i<N; i++) samples[i] = current;

            continue;
        }

        // E. PID CONTROL
        int error = distance - TARGET_DISTANCE;
        if (abs(error) < DEAD_ZONE) error = 0;

        if (abs(error) < 10) integral += error;
        else integral = 0;

        if (integral > INTEGRAL_MAX) integral = INTEGRAL_MAX;
        if (integral < -INTEGRAL_MAX) integral = -INTEGRAL_MAX;

        int derivative = error - lastError;
        float turnRatio = (KP * error) + (KI * integral) + (KD * derivative);

        int leftSpeed  = BASE_SPEED - turnRatio;
        int rightSpeed = BASE_SPEED + turnRatio;

        if (leftSpeed < 0) leftSpeed = 0;
        if (rightSpeed < 0) rightSpeed = 0;
        if (leftSpeed > 100) leftSpeed = 100;
        if (rightSpeed > 100) rightSpeed = 100;

        OnFwd(LEFT_MOTOR, leftSpeed);
        OnFwd(RIGHT_MOTOR, rightSpeed);

        lastError = error;
        Wait(40);
    }
    Off(BOTH_MOTORS);

    // --------------------------------------------------------------
    // SAVE FILE WITH 4 COLUMNS
    // --------------------------------------------------------------
    TextOut(0, LCD_LINE8, "SAVING...");
    string filename = "SLAM_PATH.TXT";
    unsigned int bw = 0;
    DeleteFile(filename);
    
    if (CreateFile(filename, 15000, fileHandle) == LDR_SUCCESS){
        
        for (int i = 0; i < pointCount; i++) {
            // Convert to large integers (matching friend's code logic)
            long xo = pathX[i] * 10000;
            long yo = pathY[i] * 10000;
            long to = pathTheta[i] * 100000;
            int dist = pathDist[i];

            // Build string: X, Y, Theta, Distance
            string s = NumToStr(xo);
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(yo));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(to));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(dist));
            s = StrCat(s, "\n");

            WriteString(fileHandle, s, bw);
        }
    }
    CloseFile(fileHandle);
    TextOut(0, LCD_LINE8, "SAVED!");
    Wait(5000);
}
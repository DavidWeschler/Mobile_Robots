// ==================================================================
// WALL FOLLOWER + MAPPING + ACCURATE SENSOR STABILIZATION
// ==================================================================

#define RIGHT_MOTOR     OUT_A
#define LEFT_MOTOR      OUT_B
#define BOTH_MOTORS     OUT_AB
#define SENSOR_MOTOR    OUT_C   // Motor to move the Light Sensor
#define ULTRASONIC_SENSOR S3
#define TOUCH_SENSOR    S1
#define LIGHT_SENSOR    S4
#define SENSOR_SPEED    30

#define FILE_NAME "TRACK_LOG.TXT"

// --- PHYSICAL CONSTANTS (cm) ---
const float WHEEL_DIAMETER = 5.6;
const float TRACK_WIDTH    = 12.1;

// --- ODOMETRY VARIABLES ---
float x_cm = 0.0;
float y_cm = 0.0;
float theta_rad = 0.0;
float total_travel_distance = 0.0;

long old_enc_left = 0;
long old_enc_right = 0;

// --- DATA LOGGING ---
#define MAX_LOG_POINTS 1800
float logX[MAX_LOG_POINTS];
float logY[MAX_LOG_POINTS];
float logTheta[MAX_LOG_POINTS];
int   logDistance[MAX_LOG_POINTS];
int   logStatus[MAX_LOG_POINTS];

int data_index = 0;
int loop_counter = 0;
#define LOG_INTERVAL 5

// --- MAPPING DISPLAY ---
#define DRAW_INTERVAL 1000
long lastDrawTime = 0;

byte fileHandle;

// --- TUNING CONSTANTS ---
const int TARGET_DISTANCE = 32;
const int DEAD_ZONE = 2;
const int BASE_SPEED = 40;
const int BLACK_THRESHOLD = 30;

// PID Constants
const float KP = 1.2;
const float KI = 0.005;
const float KD = 15.0;

const float INTEGRAL_MAX = 300;

// Filter Globals
const int N = 3;
int samples[N];
int lineCount = 0;
bool onLine = false;

// --- STABILIZER CONTROL ---
// Flag to tell the stabilizer task when to pause (during collision)
bool stabilizer_active = true;

// ------------------------------------------------------------------
// NEW TASK: Sensor Stabilizer
// Runs in parallel to keep the sensor at 0 using accurate RotateMotor
// ------------------------------------------------------------------
task SensorStabilizer() {
    while(true) {
        // Only stabilize if the main task hasn't paused us
        if (stabilizer_active) {
            long currentCount = MotorRotationCount(SENSOR_MOTOR);

            // If drifted more than 1 degree, fix it accurately
            if (abs(currentCount) > 4) {
                // RotateMotor is precise and holds position
                // We move by -currentCount to get back to 0
                RotateMotor(SENSOR_MOTOR, SENSOR_SPEED, -currentCount);
            }
        }
        // Check 10 times a second (saves CPU for main task)
        Wait(100);
    }
}

// ------------------------------------------------------------------
// FUNCTION: Filter Sensor Noise
// ------------------------------------------------------------------
int GetFilteredDistance() {
    int raw = SensorUS(ULTRASONIC_SENSOR);
    if (raw > 255) raw = 255;

    for (int i = N - 1; i > 0; i--) {
        samples[i] = samples[i - 1];
    }
    samples[0] = raw;

    int sum = 0;
    for (int i = 0; i < N; i++) {
        sum += samples[i];
    }

    return sum / N;
}

// ------------------------------------------------------------------
// FUNCTION: Check Light Sensor
// ------------------------------------------------------------------
int CheckLineStatus() {
    int current_status = 0;
    
    if (Sensor(LIGHT_SENSOR) < BLACK_THRESHOLD) {
        if (onLine == false) {
            lineCount++;
            onLine = true;
        }
        current_status = 1;
        PlaySound(SOUND_UP);
    } else {
        if (Sensor(LIGHT_SENSOR) > BLACK_THRESHOLD + 5) {
            onLine = false;
        }
        current_status = 0;
    }
    return current_status;
}

// ------------------------------------------------------------------
// FUNCTION: Redraw Map on Screen
// ------------------------------------------------------------------
void RedrawMap() {
    if (data_index < 2) return;

    float min_x = logX[0]; float max_x = logX[0];
    float min_y = logY[0]; float max_y = logY[0];

    for(int i=1; i < data_index; i++) {
        if (logX[i] < min_x) min_x = logX[i];
        if (logX[i] > max_x) max_x = logX[i];
        if (logY[i] < min_y) min_y = logY[i];
        if (logY[i] > max_y) max_y = logY[i];
    }

    float range_x = max_x - min_x;
    float range_y = max_y - min_y;

    if (range_x < 1.0) range_x = 1.0;
    if (range_y < 1.0) range_y = 1.0;

    float scale_x = 96.0 / range_x;
    float scale_y = 60.0 / range_y;

    float scale = scale_x;
    if (scale_y < scale_x) scale = scale_y;

    ClearScreen();

    int sx = (logX[0] - min_x) * scale + 2;
    int sy = (logY[0] - min_y) * scale + 2;
    CircleOut(sx, sy, 2);

    for(int i=0; i < data_index-1; i++) {
        int x1 = (logX[i]   - min_x) * scale + 2;
        int y1 = (logY[i]   - min_y) * scale + 2;
        int x2 = (logX[i+1] - min_x) * scale + 2;
        int y2 = (logY[i+1] - min_y) * scale + 2;

        LineOut(x1, y1, x2, y2);
    }

    int ex = (logX[data_index-1] - min_x) * scale + 2;
    int ey = (logY[data_index-1] - min_y) * scale + 2;
    LineOut(ex-2, ey-2, ex+2, ey+2);
    LineOut(ex-2, ey+2, ex+2, ey-2);
}

// ------------------------------------------------------------------
// FUNCTION: Save File
// ------------------------------------------------------------------
void WriteLogToFile()
{
    DeleteFile(FILE_NAME);
    if (CreateFile(FILE_NAME, 20000, fileHandle) == LDR_SUCCESS)
    {
        TextOut(0, LCD_LINE1, "SAVING...");

        for (int i = 0; i < data_index; i++)
        {
            long xo = logX[i] * 10000;
            long yo = logY[i] * 10000;
            long to = logTheta[i] * 100000;

            string s = NumToStr(xo);
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(yo));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(to));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(logDistance[i]));
            s = StrCat(s, ",");
            s = StrCat(s, NumToStr(logStatus[i]));
            s = StrCat(s, "\n");

            unsigned int bw = 0;
            WriteString(fileHandle, s, bw);
        }

        CloseFile(fileHandle);
        PlaySound(SOUND_UP);
        TextOut(0, LCD_LINE3, "DONE!");
        Wait(2000);
    }
    else {
        TextOut(0, LCD_LINE1, "SAVE ERROR");
        PlaySound(SOUND_LOW_BEEP);
        Wait(2000);
    }
}

// ------------------------------------------------------------------
// FUNCTION: Odometry Log
// ------------------------------------------------------------------
void odometry_log(int distance, int status){
    long curr_enc_left  = MotorRotationCount(LEFT_MOTOR);
    long curr_enc_right = MotorRotationCount(RIGHT_MOTOR);

    long d_ticks_left  = curr_enc_left  - old_enc_left;
    long d_ticks_right = curr_enc_right - old_enc_right;

    old_enc_left  = curr_enc_left;
    old_enc_right = curr_enc_right;

    float d_left  = d_ticks_left  * (PI * WHEEL_DIAMETER / 360.0);
    float d_right = d_ticks_right * (PI * WHEEL_DIAMETER / 360.0);

    float d_center = (d_left + d_right) / 2.0;

    total_travel_distance += abs(d_center);

    float d_theta  = (d_right - d_left) / TRACK_WIDTH;

    float avg_theta = theta_rad + (d_theta / 2.0);

    x_cm += d_center * cos(avg_theta);
    y_cm += d_center * sin(avg_theta);
    theta_rad += d_theta;

    if (data_index < MAX_LOG_POINTS)
    {
        logX[data_index]     = x_cm;
        logY[data_index]     = y_cm;
        logTheta[data_index] = theta_rad;
        logDistance[data_index] = distance;
        logStatus[data_index] = status;
        data_index++;
    }
}

// ------------------------------------------------------------------
// MAIN TASK
// ------------------------------------------------------------------
task main()
{
    SetSensorLowspeed(ULTRASONIC_SENSOR);
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorLight(LIGHT_SENSOR, true);

    // Initialize filter
    int initialDist = SensorUS(ULTRASONIC_SENSOR);
    for (int i = 0; i < N; i++) {
        if (initialDist > 255) initialDist = 255;
        samples[i] = initialDist;
    }

    ResetTachoCount(LEFT_MOTOR);
    ResetTachoCount(RIGHT_MOTOR);

    // SETUP SENSOR MOTOR
    ResetTachoCount(SENSOR_MOTOR); // Assume current position is 0 (Forward)
    stabilizer_active = true;
    StartTask(SensorStabilizer);   // START THE PARALLEL TASK

    old_enc_left = 0;
    old_enc_right = 0;

    float integral = 0;
    int lastError = 0;
    lastDrawTime = CurrentTick();

    // ----------------- MAIN LOOP -----------------
    while (true) {

        // 0. EXIT CONDITION
        if (total_travel_distance >= 1100.0) {
            stabilizer_active = false; // Stop the helper task
            Off(OUT_AB);
            PlaySound(SOUND_DOWN);
            break;
        }

        // 1. DATA GATHERING
        int distance = GetFilteredDistance();
        int line_status = CheckLineStatus();

        loop_counter++;

        // 2. LOGGING
        if (loop_counter >= LOG_INTERVAL || line_status == 1)
        {
            odometry_log(distance, line_status);
            loop_counter = 0;
        }

        // 3. MAP REDRAW
        if (CurrentTick() - lastDrawTime > DRAW_INTERVAL) {
            RedrawMap();
            lastDrawTime = CurrentTick();
        }

        // 4. COLLISION RECOVERY
        if (Sensor(TOUCH_SENSOR) == 1) {
            Off(LEFT_MOTOR);
            Off(RIGHT_MOTOR);

            // --- PAUSE STABILIZER ---
            stabilizer_active = false;
            Wait(100); // Give the stabilizer task a moment to finish any active move

            odometry_log(distance, 2);
            
            // RETRACT SENSOR (Accurate Move)
            // Using RotateMotor here is safe because main loop is waiting anyway
            RotateMotor(SENSOR_MOTOR, SENSOR_SPEED, 90);

            // Back up
            RotateMotor(BOTH_MOTORS, BASE_SPEED, -360);

            Wait(200);

            // Turn Right
            RotateMotor(RIGHT_MOTOR, BASE_SPEED, -360);

            // RESTORE SENSOR (Accurate Move)
            // Move back to 0 (Forward)
            // Since we are at -90, moving +90 brings us to 0.
            RotateMotor(SENSOR_MOTOR, SENSOR_SPEED, -90);

            distance = GetFilteredDistance();
            odometry_log(distance, 0);

            // --- RESUME STABILIZER ---
            stabilizer_active = true;

            integral = 0;
            lastError = 0;

            int current = SensorUS(ULTRASONIC_SENSOR);
            for (int i = 0; i < N; i++) {
                samples[i] = current;
            }

            continue;
        }

        // --- PID CONTROL ---

        int error = distance - TARGET_DISTANCE;

        if (abs(error) < DEAD_ZONE) error = 0;

        if (abs(error) < 15) integral += error;
        else integral = 0;

        if (integral > INTEGRAL_MAX) integral = INTEGRAL_MAX;
        if (integral < -INTEGRAL_MAX) integral = -INTEGRAL_MAX;

        int derivative = error - lastError;

        float turnRatio = (KP * error) + (KI * integral) + (KD * derivative);

        int leftSpeed  = BASE_SPEED - turnRatio;
        int rightSpeed = BASE_SPEED + turnRatio;

        if (leftSpeed < 0) leftSpeed = 0;
        if (rightSpeed < 0) rightSpeed = 0;
        if (leftSpeed > 100) leftSpeed = 100;
        if (rightSpeed > 100) rightSpeed = 100;

        OnFwd(LEFT_MOTOR, leftSpeed);
        OnFwd(RIGHT_MOTOR, rightSpeed);

        lastError = error;

        Wait(40);
    }

    WriteLogToFile();
    Wait(10000);
}
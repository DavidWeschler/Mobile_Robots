// ==================================================================
// WALL FOLLOWER + REAL-TIME MAPPING
// ==================================================================

#define RIGHT_MOTOR     OUT_A
#define LEFT_MOTOR      OUT_B
#define BOTH_MOTORS     OUT_AB

#define ULTRASONIC_SENSOR S4
#define TOUCH_SENSOR    S1
#define SOUND_SENSOR    S2

// --- PHYSICAL CONSTANTS ---
const float WHEEL_DIAMETER = 5.6;
const float TRACK_WIDTH    = 11.8;

// --- MAPPING CONSTANTS ---
// 0.5 means 1 cm of movement = 0.5 pixels on screen.
// Adjust this: if map is too big, make smaller (0.3). If too small, make bigger (1.0).
const float MAP_SCALE = 0.6;
const int START_X_PIXEL = 50; // Start in middle of screen width
const int START_Y_PIXEL = 10; // Start near bottom of screen

// --- TUNING ---
const int TARGET_DISTANCE = 30;
const int BASE_SPEED = 50;
const int BLACK_THRESHOLD = 30;
const int TARGET_LINE_COUNT = 8;

// --- ODOMETRY VARIABLES ---
float x_cm = 0.0;
float y_cm = 0.0;
float theta_rad = 1.57; // Start facing UP (90 degrees = PI/2)

long old_enc_left = 0;
long old_enc_right = 0;

// Screen previous coordinates (to draw connecting lines)
int prev_screen_x = START_X_PIXEL;
int prev_screen_y = START_Y_PIXEL;

// --- PID VARIABLES ---
const float KP = 1.2;
const float KI = 0.005;
const float KD = 15.0;
const int DEAD_ZONE = 2;
const float INTEGRAL_MAX = 300;

// --- GLOBAL VARIABLES ---
int lineCount = 0;
bool onLine = false;
const int N = 3;
int samples[N];

// ------------------------------------------------------------------
// FUNCTION: Filter Sensor Noise
// ------------------------------------------------------------------
int GetFilteredDistance() {
    int raw = SensorUS(ULTRASONIC_SENSOR);
    if (raw > 255) raw = 255;
    for (int i = N - 1; i > 0; i--) samples[i] = samples[i - 1];
    samples[0] = raw;
    int sum = 0;
    for (int i = 0; i < N; i++) sum += samples[i];
    return sum / N;
}

// ------------------------------------------------------------------
// FUNCTION: Update Odometry & Draw on Screen
// ------------------------------------------------------------------
void UpdateOdometryAndDraw() {
    // 1. Calculate Motion
    long curr_enc_left  = MotorRotationCount(LEFT_MOTOR);
    long curr_enc_right = MotorRotationCount(RIGHT_MOTOR);

    long d_ticks_left  = curr_enc_left  - old_enc_left;
    long d_ticks_right = curr_enc_right - old_enc_right;

    old_enc_left  = curr_enc_left;
    old_enc_right = curr_enc_right;

    float dist_per_tick = (PI * WHEEL_DIAMETER) / 360.0;
    float d_left  = d_ticks_left  * dist_per_tick;
    float d_right = d_ticks_right * dist_per_tick;

    float d_center = (d_left + d_right) / 2.0;
    float d_theta  = (d_right - d_left) / TRACK_WIDTH;

    float avg_theta = theta_rad + (d_theta / 2.0);

    x_cm += d_center * cos(avg_theta);
    y_cm += d_center * sin(avg_theta);
    theta_rad += d_theta;

    // 2. Convert to Screen Coordinates
    // We add the START offsets to center the map
    int curr_screen_x = START_X_PIXEL + (x_cm * MAP_SCALE);
    int curr_screen_y = START_Y_PIXEL + (y_cm * MAP_SCALE);

    // 3. Draw Line from Previous Point to Current Point
    // This creates a continuous trail even if the loop is slow
    LineOut(prev_screen_x, prev_screen_y, curr_screen_x, curr_screen_y);

    // 4. Update Previous History
    prev_screen_x = curr_screen_x;
    prev_screen_y = curr_screen_y;
}

// ------------------------------------------------------------------
// MAIN TASK
// ------------------------------------------------------------------
task main()
{
    // Setup
    SetSensorLowspeed(ULTRASONIC_SENSOR);
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorSound(SOUND_SENSOR);

    ResetTachoCount(LEFT_MOTOR);
    ResetTachoCount(RIGHT_MOTOR);

    // Init Filter
    int initialDist = SensorUS(ULTRASONIC_SENSOR);
    for (int i = 0; i < N; i++) samples[i] = initialDist;

    // Variables
    float integral = 0;
    int lastError = 0;

    // --- SCREEN SETUP ---
    ClearScreen();
    TextOut(0, LCD_LINE8, "Lines: 0"); // Initialize text at bottom
    CircleOut(START_X_PIXEL, START_Y_PIXEL, 2); // Draw start point

    // ----------------- MAIN LOOP -----------------
    while (Sensor(SOUND_SENSOR) < 99) {

        // A. UPDATE MAP
        UpdateOdometryAndDraw();

        // C. EXIT CONDITION
        if (lineCount >= TARGET_LINE_COUNT) {
            Off(BOTH_MOTORS);
            PlaySound(SOUND_UP);
            TextOut(0, LCD_LINE1, "DONE!");
            Wait(10000); // Wait so you can admire the map
            break;
        }

        int distance = GetFilteredDistance();

        // D. COLLISION RECOVERY
        if (Sensor(TOUCH_SENSOR) == 1) {
            Off(BOTH_MOTORS);
            PlaySound(SOUND_LOW_BEEP);
            Wait(200);

            // Back up
            RotateMotor(BOTH_MOTORS, BASE_SPEED, -240);

            // Spin
            RotateMotor(RIGHT_MOTOR, BASE_SPEED, -360);

            // Because RotateMotor stops the code execution,
            // we run this ONCE immediately to catch up the map drawing
            UpdateOdometryAndDraw();

            // Reset PID
            integral = 0;
            lastError = 0;

            // Refill filter
            int current = SensorUS(ULTRASONIC_SENSOR);
            for (int i=0; i<N; i++) samples[i] = current;

            continue;
        }

        // E. PID CONTROL
        int error = distance - TARGET_DISTANCE;
        if (abs(error) < DEAD_ZONE) error = 0;

        if (abs(error) < 10) integral += error;
        else integral = 0;

        // Clamp Integral
        if (integral > INTEGRAL_MAX) integral = INTEGRAL_MAX;
        if (integral < -INTEGRAL_MAX) integral = -INTEGRAL_MAX;

        int derivative = error - lastError;
        float turnRatio = (KP * error) + (KI * integral) + (KD * derivative);

        int leftSpeed  = BASE_SPEED - turnRatio;
        int rightSpeed = BASE_SPEED + turnRatio;

        // Clamp Speeds
        if (leftSpeed < 0) leftSpeed = 0;
        if (rightSpeed < 0) rightSpeed = 0;
        if (leftSpeed > 100) leftSpeed = 100;
        if (rightSpeed > 100) rightSpeed = 100;

        OnFwd(LEFT_MOTOR, leftSpeed);
        OnFwd(RIGHT_MOTOR, rightSpeed);

        lastError = error;
        Wait(40);
    }
}